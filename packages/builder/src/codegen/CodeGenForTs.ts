import { CodeGen } from './CodeGen';
import { buildUnionType, ss, t2s } from '../helpers/tsHelper';
import type { Root } from '../models/Root';
import type { Route } from '../models/Route';
import { Enum, EnumConstant, Member } from '../models';
import { isJavaNumber } from '../helpers/javaHelper';

interface Options {
  /**
   * API Base URI
   */
  base?: string;

  /**
   * Appended static properties
   */
  properties?: Record<string, string | number | boolean | undefined>;

  /**
   * @default false;
   */
  noHead?: boolean;

  /**
   * @default "@huolala-tech/nad-runtime"
   */
  runtimePkgName?: string;
}

export class CodeGenForTs extends CodeGen {
  private readonly root;
  private readonly options;

  constructor(root: Root, options: Options) {
    super();
    this.root = root;
    this.options = options;
    if (!options.noHead) {
      this.write('/* 该文件由 Nad CLI 生成，请勿手改 */');
      this.write('/* This file is generated by Nad CLI, do not edit manually. */');
      this.write('/* eslint-disable */');
      this.write('');
    }
    const runtimePkgName = options.runtimePkgName || '@huolala-tech/nad-runtime';
    const { base, properties } = this.options;
    this.write(`import { NadInvoker } from '${runtimePkgName}';`);
    this.write(`import type { Settings } from '${runtimePkgName}';`);
    this.write('');
    this.write(`export class Runtime<T = unknown> extends NadInvoker<T> {`);
    this.writeBlock(() => {
      if (base !== undefined) this.write(`public static base = ${ss(base)};`);
      if (properties) {
        Object.keys(properties).forEach((key) => {
          const value = properties[key];
          if (value !== undefined) this.write(`public static ${key} = ${ss(value)};`);
        });
      }
    });
    this.write(`}`);
    this.write('');
    this.writeModules();
    this.writeClasses();
    this.writeEnums();
    this.writeCommonDefs();
  }

  /**
   * TS does not allow a required parameter follow an optional parameter, see https://typescript.tv/errors/#TS1016
   * We have two solutions here:
   * 1. Sort the parameter list, making all required parameters be advanced.
   * 2. For all optional parameters to left of the last required parameter,
   *    change them to required (to ensure that no optional parameters are defined before any required parameters),
   *    and change their types to `T | null` (to ensure that the original optional parameters can be null).
   * The solution 1 breaks uniformity with Java definitions and may lead to confusion among some developers,
   * so use the solution 2 here.
   */
  private getPars(a: Route) {
    let hasRequired = false;
    const pars = a.parameters
      // The below `reverse` method will modify the original array, so use `slice(0)` to create a copy.
      .slice(0)
      // The `map` method does not support right-to-left, so reverse the array first.
      .reverse()
      .map((p) => {
        // If a parameter is optional and has any required parameters in the right,
        // then change its type to `T | null` and make it requreid.
        if (hasRequired && p.required === '?') return `${p.name}: ${t2s(p.type)} | undefined`;
        // If current parameter is required, update `hasRequired` flag to `true`.
        hasRequired = hasRequired || p.required === '';
        // Otherwise, the current parameter is requreid, or there are no required parameters to its right,
        // so the original parameter settings should be maintained.
        return `${p.name}${p.required}: ${t2s(p.type)}`;
      })
      // Reverse again to offset the previous reverse.
      .reverse();
    pars.push('settings?: Partial<Settings>');
    return pars;
  }

  private writeApi(a: Route) {
    const pars = this.getPars(a);
    this.writeComment(() => {
      this.write(a.description || a.name);
      for (const p of a.parameters) {
        if (p.description) this.write(`@param ${p.name} ${p.description}`);
      }
      if (a.deprecated) this.write('@deprecated');
    });
    this.write(`async ${a.uniqName}(${pars.join(', ')}) {`);
    this.writeBlock(() => {
      this.write(`return new Runtime<${t2s(a.returnType)}>()`);
      this.writeBlock(() => {
        this.write(`.open(${ss(a.method)}, ${ss(a.pattern)}, settings)`);
        for (const [key, value] of a.requiredHeaders) {
          this.write(`.addHeader(${ss(key)}, ${ss(value)})`);
        }
        for (const [key, value] of a.requiredParams) {
          this.write(`.addStaticParam(${ss(key)}, ${ss(value)})`);
        }
        if (a.customFlags.length) {
          this.write(`.addCustomFlags(${a.customFlags.map(ss).join(', ')})`);
        }
        for (const p of a.parameters) {
          for (const [m, ...args] of p.actions) {
            if (args.length) {
              this.write(`.${m}(${args.map(ss).join(', ')}, ${p.name})`);
            } else {
              this.write(`.${m}(${p.name})`);
            }
          }
        }
        this.write(`.execute();`);
      });
    });
    this.write('},');
  }

  private writeModules() {
    for (const m of this.root.modules) {
      this.writeComment(() => {
        this.write(m.description || m.moduleName);
        this.write(`@iface ${m.name}`);
        if (m.deprecated) this.write(`@deprecated`);
      });
      this.write(`export const ${m.moduleName} = {`);
      this.writeBlock(() => {
        for (const a of m.routes) this.writeApi(a);
      });
      this.write('};', '');
    }
  }

  private writeCommonDefs() {
    for (const [alias, tsType] of this.root.commonDefs) {
      this.write(`export type ${alias} = ${tsType};`);
      this.write('');
    }
  }

  private writeEnums() {
    for (const e of this.root.enumList) {
      if (e.description) {
        this.writeComment(() => {
          this.write(e.description);
        });
      }
      this.write(`export enum ${e.simpleName} {`);
      this.writeBlock(() => {
        let p: EnumConstant | null = null;
        for (const v of e.constants) {
          if (v.description) {
            this.writeComment(() => {
              this.write(v.description);
            });
          }
          // TypeScript Enum type supports the iota style.
          // The item value can be omitted if it is equal to the previous item plus 1.
          // Additionally, the first item value can also be omitted if it is zero.
          if ((!p && v.value === 0) || (p && typeof p.value === 'number' && v.value === p.value + 1)) {
            this.write(`${v.name},`);
          } else {
            this.write(`${v.name} = ${ss(v.value)},`);
          }
          if (v.memo) this.amend((s) => `${s} // ${v.memo}`);
          p = v;
        }
      });
      this.write('}');
      this.write('');
    }
  }

  private writeClasses() {
    for (const c of this.root.declarationList) {
      this.writeComment(() => {
        this.write(c.description || c.simpleName);
        this.write(`@iface ${c.name}`);
      });
      const { defName } = c;
      if (c.members.length) {
        let defStr = defName;
        if (c.superclass) {
          const type = t2s(c.superclass);
          if (type !== 'any' && type !== 'unknown') defStr += ` extends ${type}`;
        }
        this.write(`export interface ${defStr} {`);
        this.writeBlock(() => {
          for (const m of c.members) {
            if (m.description || m.deprecated) {
              this.writeComment(() => {
                this.write(m.description);
                if (m.deprecated) this.write('@deprecated');
              });
            }
            this.write(`${m.name}${m.optional}: ${this.buildMemberType(m)};`);
          }
        });
        this.write('}');
      } else {
        this.write(`export type ${c.defName} = ${t2s(c.superclass)};`);
      }
      this.write('');
    }
  }

  private buildMemberType(m: Member) {
    const { type, narrowValues } = m;
    if (!narrowValues) return t2s(type);
    const { clz } = m.type;
    if (clz instanceof Enum) {
      const vs = narrowValues.map((i) => (clz.valueType === 'number' ? Number(i) : i)).map(ss);
      return `Extract<${t2s(type)}, ${buildUnionType(...vs)}>`;
    } else {
      const vs = narrowValues.map((i) => (isJavaNumber(type.name) ? Number(i) : i)).map(ss);
      return buildUnionType(...vs);
    }
  }
}
